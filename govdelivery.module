<?php

/**
 * Define message queue table.
 */
define('MESSAGE_QUEUE_TABLE', 'govdelivery_message_queue');

/**
 * Define subscription queue table.
 */
define('SUBSCRIPTION_QUEUE_TABLE', 'govdelivery_subscription_queue');

/**
 * Implements hook_perm().
 */
function govdelivery_perm() {
  return array('Manage GovDelivery Settings', 'GovDelivery Testing', 'GovDelivery Reports');
}

/**
 * Implements hook_menu().
 */
function govdelivery_menu() {
  $items['admin/settings/govdelivery'] = array(
    'title' => 'GovDelivery Settings',
    'description' => 'Settings for GovDelivery to connect with the GovDelivery ODM and Subscription service.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('govdelivery_settings'),
    'access arguments' => array('Manage GovDelivery Settings'),
    'file' => 'govdelivery.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/settings/govdelivery/test_message'] = array(
    'title' => 'GovDelivery Settings Test - Message',
    'description' => 'Test sending messages, through Drupal, correctly routed to the GovDelivery service.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('govdelivery_test_message'),
    'access arguments' => array('Manage GovDelivery Settings'),
    'file' => 'govdelivery.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/settings/govdelivery/test_subscription'] = array(
    'title' => 'GovDelivery Settings Test - Subscription',
    'description' => 'Test signup process for GovDelivery Subscription services.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('govdelivery_test_subscription'),
    'access arguments' => array('Manage GovDelivery Settings'),
    'file' => 'govdelivery.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/reports/govdelivery_message_queue'] = array(
    'title' => 'GovDelivery Message Queue',
    'description' => 'View current items in the message queue.',
    'page callback' => 'govdelivery_message_queue_report',
    'page arguments' => array(),
    'access arguments' => array('Manage GovDelivery Settings'),
    'file' => 'govdelivery.admin-reports.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/reports/govdelivery_message_queue/details/%'] = array(
    'title' => 'GovDelivery Message Details',
    'description' => 'Details of a queued messaged',
    'page callback' => 'govdelivery_details',
    'page arguments' => array(1),
    'access arguments' => array('Manage GovDelivery Settings'),
    'file' => 'govdelivery.admin-reports.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_cron
 */
function govdelivery_cron() {
  $messages_sent = govdelivery_process_message_queue();
  $subscriptions_sent = govdelivery_process_subscription_queue();
}

/**
 * @TODO try to eliminate this function if possible. Or make it more similar to process message.
 * 
 * @param type $item 
 */
function govdelivery_queued_subscribe($item) {
  govdelivery_subscribe($item['code'], $item['email'], TRUE);
}

function govdelivery_process_message_queue($items = NULL, $ignore_max_time = FALSE, $cid=NULL) {
  $messages_sent = govdelivery_process_queue(MESSAGE_QUEUE_TABLE, 'govdelivery_send_message', $items, $ignore_max_time, $cid);
  watchdog('govdelivery', 'Sent %messages messages when processing the govdelivery messsage queue.', array( '%messages' => $messages_sent), WATCHDOG_INFO);
}

function govdelivery_process_subscription_queue($items = NULL, $ignore_max_time = FALSE, $cid = NULL) {
  $subscriptions = govdelivery_process_queue(SUBSCRIPTION_QUEUE_TABLE, 'govdelivery_queued_subscribe', $items, $ignore_max_time, $cid);
  watchdog('govdelivery', 'Subscribed %subscriptions emails when processing the govdelivery subscription queue.', array( '%subscriptions' => $subscriptions_processed), WATCHDOG_INFO);
}

function govdelivery_process_queue($queue, $callback, $items = NULL, $ignore_max_time = FALSE, $cid=NULL) {
  // checks for maximum execution time cribbed from the job_queue module: drupal.org/project/job_queue
  $max_execution_time = ini_get('max_execution_time');
  if (!$ignore_max_time && empty($max_execution_time)) {
    $max_execution_time = 5 * 60;
  }

  $start_time = (timer_read('page') / 1000);

  // setting a simple semaphore to avoid parallelism issues
  $semaphore = variable_get('govdelivery_semaphore', FALSE);
  if ($semaphore) {
    watchdog('govdelivery', 'Attempting to re-run govdelivery queue processing while it is already running.', array(), WATCHDOG_WARNING);
    return FALSE;
  }
  else {
    // in case we are aborted, register a shutdown callback
    register_shutdown_function('govdelivery_process_queue_cleanup');
    $items_sent = 0;

    $cache_queue = db_query("SELECT cid FROM {" . $queue . "} ORDER BY created ASC");

    while ($queue_key = db_fetch_object($cache_queue)) {
      // check our status against the maximum execution time for a request, and if we've used half of it we want to
      // stop processing - it was formerly checking whether half the time was used, rather than whether we had used
      // half of it in this module
      if (!$ignore_max_time && ( ((timer_read('page') / 1000) - $start_time ) > ($max_execution_time / 2))) {
        watchdog('govdelivery', 'Half of the available PHP execution time of %max_execution_time has been use processing the GovDelivery queue and processing will not continue.',
          array( '%max_execution_time' => $max_execution_time), WATCHDOG_WARNING);
        break;  // Stop once we have used over half of the maximum execution time
      }

      $i = $queue_key->cid;
      // Only send one message from the queue if a cid is passed in
      // If the cid is null or blank process the queue as normal
      if ((!empty($cid) && $i == $cid) || (empty($cid))) {
        // get the most recently cached item
        $item = govdelivery_queue_get($queue, $i);
        // if this item is still in the cache
        if ($item) {
          // resend the item
          // add a callback
          $status = call_user_func_array($callback, array($item) );
          if ($status) {
            govdelivery_queue_remove($queue, $i);
            $items_sent++;
          }
        }
      }
      if (isset($items) && ( $items_sent >= $items )) break;   // break if we've sent the requested number of items
    }

    variable_set('govdelivery_semaphore', time());
    variable_del('govdelivery_semaphore');
    return $items_sent;
  }
}

function govdelivery_process_queue_cleanup() {
  if (variable_get('govdelivery_semaphore', FALSE)) {
    watchdog('govdelivery', 'GovDelivery queue processing was aborted unexpectedly.  This could mean that the maximum execution time was exceeded or an uncaught exception occured in SOAP processing.', array(), WATCHDOG_WARNING);

    // Release cron semaphore
    variable_del('govdelivery_semaphore');
  }
}

function govdelivery_queue_get($queue, $cid) {
  global $user;

  $message = db_fetch_object(db_query("SELECT data, created, headers, expire, serialized FROM {" . $queue . "} WHERE cid = '%s'", $cid));
  if (isset($message->data)) {
    // If the data is permanent or we're not enforcing a minimum cache lifetime
    // always return the cached data.
    $message->data = db_decode_blob($message->data);
    if ($message->serialized) {
        $message->data = unserialize($message->data);
    }
    return $message->data;
  }
  return 0;
}

function govdelivery_queue_set($queue, $cid, $data) {
  $serialized = 0;
  if (is_object($data) || is_array($data)) {
    $data = serialize($data);
    $serialized = 1;
  }
  $created = time();
  db_query("UPDATE {" . $queue . "} SET data = %b, created = %d, serialized = %d WHERE cid = '%s'", $data, $created, $expire, $headers, $serialized, $cid);
  if (!db_affected_rows()) {
    @db_query("INSERT INTO {" . $queue . "} (cid, data, created, serialized) VALUES ('%s', %b, %d, %d)", $cid, $data, $created, $serialized);
  }
}

function govdelivery_queue_remove($queue, $cid) {
  global $user;
  db_query("DELETE FROM {" . $queue . "} WHERE cid = '%s'", $cid);
}

function govdelivery_send_message($message) {
  $govdelivery_odm_settings = variable_get('govdelivery_odm_settings', array());
  $sendsuccess = TRUE;

  if (class_exists('SoapClient')) {
    include_once('odmService.php');

    $email = new odmService($govdelivery_odm_settings['server']);

    $ODMmessage = new ODMMessage();

    $recipients = array();
    if (is_array($message["to"])) {
      foreach ($message["to"] as $address) {
        $tolist = explode(',', $address);
        if (is_array($tolist)) {
          $filtered_list = array_map("govdelivery_filter_email", $tolist);
          $recipients = array_merge($recipients, $filtered_list);
        }
        else {
          $recipients[] = govdelivery_filter_email($tolist);
        }
      }
    }
    else {
      $recipients = explode(',', $message["to"]);
    }

    $ODMmessage->to = (array)$recipients;
    $account_map = variable_get("govdelivery_account_map", NULL);

    if (isset($account_map)) {
      $account = $account_map[$message["id"]];
      if (!isset($account)) {
        $account = $account_map["default"];
        if (!isset($account)) {
          watchdog('govdelivery', 'No default account specified.  Check settings.php.', NULL, WATCHDOG_ERROR);
          return FALSE;
        }
      }

      $ODMmessage->fromName = $govdelivery_odm_settings['accounts'][$account]['fromname'];
      $ODMmessage->userName = $account;
      $ODMmessage->password = $govdelivery_odm_settings['accounts'][$account]['password'];
    }
    else {
      watchdog('govdelivery', 'GovDelivery account mapping has not been set.  Check settings.php.', NULL, WATCHDOG_ERROR);
      return FALSE;
    }

    // check for XML/XHTML or oldstyle html
    $xml_start = strpos(trim($message["body"]), "<?xml");
    $html_start = strpos(trim($message["body"]), "<html");

    // GovDelivery doesn't let us set the MIME type, it will send as text/html ... wrap with <pre> to
    // allow for clean formatting if message isn't XML or HTML already
    if ($xml_start === 0 && $html_start === 0) {
      $ODMmessage->body = $message["body"];
    }
    else {
      $ODMmessage->body = '<pre>' . $message["body"] . '</pre>';
    }
    $ODMmessage->subject = $message["subject"];
    $ODMmessage->recordDesignator = "email";
    $ODMmessage->emailColumn = "email";

    $status = $email->sendMessage($ODMmessage);
    if ($status) {
      $sendsuccess = !$status[0]; // 0 is successfull !0 is fail.
    }
    else {
      $sendsuccess = FALSE;
    }
  }
  else {
    $sendsuccess = FALSE;
  }

  if (!$sendsuccess) {
    watchdog('govdelivery', 'The soap client failed to send a message. It will be queued for resend on the next cron run', NULL, WATCHDOG_WARNING);
  }

  return $sendsuccess;
}

// Subscribe a user to a list via webservice
function govdelivery_subscribe($list_code, $email, $from_queue = FALSE) {
  // Check the initial prototype input.
  if (is_null($list_code) || empty($list_code)) {
    watchdog('govdelivery', 'Supplied list code is null or empty.', array(), WATCHDOG_ERROR);
    return FALSE;
  }
  else if (is_null($email) || empty($email)) {
    watchdog('govdelivery', 'Supplied email is null or empty.', array(), WATCHDOG_ERROR);
    return FALSE;
  }
  else {
    // Prototype input is good now lets check the settings.
    $request =  array('code' => $list_code, 'email' => $email);
    $key = md5(print_r($request, TRUE) . microtime() . strval(rand()));
    $govdelivery_subscription_settings = variable_get('govdelivery_subscription_settings', NULL);
   if (is_null($govdelivery_subscription_settings) || empty($govdelivery_subscription_settings)) {
      if (!from_queue) {
        govdelivery_queue_set('govdelivery_subscription_queue', $key, $request);
      }
      watchdog('govdelivery', 'Settings for subscribing this user are not available. Subscription will be queued.', array(), WATCHDOG_ERROR);
      return FALSE;
    }
   else {
      // General settings exist, check the specific settings we need.
      $service_url = $govdelivery_subscription_settings['service_url'];
      if (is_null($service_url) || empty($service_url)) {
        if (!from_queue) {
          govdelivery_queue_set('govdelivery_subscription_queue', $key, $request);
        }
        watchdog('govdelivery', 'Service URL for subscribing this user is not available. Subscription will be queued.', array(), WATCHDOG_ERROR);
        return FALSE;
      }
      else { 
        // Settings are valid now send the request.
        $request_url = url($service_url, array('query' => $request));
        $response = drupal_http_request($request_url);

        // The response is well-formed XML, but seems pretty heavyweight to parse as XML,
        // we're better off with a simple regex match
        $matches = array();
        preg_match("/<response code='(\d+)' message='(.*)'><\/response>/", $response->data, $matches);
        $result_code = $matches[1];
        $message = $matches[2];

        // Check if the request was successful or queue if needed.
        if ($result_code == "200") {
          watchdog('govdelivery', 'Subscribed %email to list %list', array('%email' => $request['email'], '%list' => $request['code']), WATCHDOG_INFO);
          return TRUE;
        }
        else {
          if (!$from_queue) {
            govdelivery_queue_set('govdelivery_subscription_queue', $key, $request);
          }
          watchdog('govdelivery', 'Error subscribing %email to list %list. Response %response:  %message; message will be queued',
            array( '%email' => $request['email'], '%list' => $request['code'], '%response' => $result_code, '%message' => $message), WATCHDOG_ERROR);
          return FALSE;
        }
      }
    }
  }
}

// the user may have put in an address of the form "Full Name" <email@domain.tld> instead of just the address,
// so we want to filter to the right address
function govdelivery_filter_email($address) {

  // borrowed from the drupal valid_email_address($mail) function
  $user = '[a-zA-Z0-9_\-\.\+\^!#\$%&*+\/\=\?\`\|\{\}~\']+';
  $domain = '(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.?)+';
  $ipv4 = '[0-9]{1,3}(\.[0-9]{1,3}){3}';
  $ipv6 = '[0-9a-fA-F]{1,4}(\:[0-9a-fA-F]{1,4}){7}';

  // setup an array for the matching expression
  $matches = array();

  // the regex below is adapted from drupal's valid_email_address($mail) function
  preg_match("/$user@($domain|(\[($ipv4|$ipv6)\]))/", $address, $matches);
  return $matches[0];
}

// Send messages immediately or to the queue if enabled.
function govdelivery_process_message($key, $message) {
  // Check preferences
  $govdelivery_odm_settings = variable_get('govdelivery_odm_settings', array());
  $send_success = FALSE;

  // Attempt to send immediately
  if (isset($govdelivery_odm_settings['queue']) && !$govdelivery_odm_settings['queue']) {
    $send_success = govdelivery_send_message($message);

    if ($send_success) {
      watchdog('govdelivery', 'Successfully sent a message immediately.', array(), WATCHDOG_INFO);
    }
  }

  // Queue the message if:
  // 1. Failure to send immediately
  // 2. Queue preferences haven't been set
  // 3. Queue is enabled
  if (!$send_success) {
    govdelivery_queue_set('govdelivery_message_queue', $key, $message);
  }
}// End govdelivery_send.


// Implement nagios_info hook to allow enabling/disabling our nagios notifications.
function govdelivery_nagios_info() {
  return array(
    'name' => 'GovDelivery',
    'id' => 'GovDelivery',
  );
} // End govdelivery_nagios_info.

/**
 * Implementation of hook_nagios.
 */
function govdelivery_nagios() {
  $table = 'govdelivery_message_queue';

  // Get the user settings.
  $critical_threshold = variable_get('govdelivery_nagios_critical_threshold', 5000);
  $warning_threshold = variable_get('govdelivery_nagios_warning_threshold', 1000);

  // Query for a backlog.
  $count = db_result(db_query('SELECT COUNT(cid) FROM {'. $table .'}'));

  if (is_numeric($count) && is_numeric($critical_threshold) && is_numeric($warning_threshold)) {
    if ($count > $critical_threshold) {
      $status = NAGIOS_STATUS_CRITICAL;
      $text = t("GovDelivery has @count backlogged messages in the queue.", array('@count' => $count));
    }
    elseif ($count > $warning_threshold) {
      $status = NAGIOS_STATUS_WARNING;
      $text = t("GovDelivery has @count backlogged messages in the queue.", array('@count' => $count));
    }
    else {
      $status = NAGIOS_STATUS_OK;
      $text = '';
    }
  }
  else {
    $status = NAGIOS_STATUS_UNKNOWN;
    $text = t("GovDelivery can't determine the queue status");
  }

  return array(
    'key' => 'GovDelivery Message Queue',
    'data' => array(
      'status' => $message_queue_status,
      'type' => 'state',
      'text' => $message_queue_text,
    ),
    'key' => 'GovDelivery Subscription Queue',
    'data' => array(
      'status' => $subscription_queue_status,
      'type' => 'state',
      'text' => $subscription_queue_text,
    )
  );
}// End govdelivery_nagios.

// Add settings to the nagios configuration page.
function govdelivery_nagios_settings() {
  $form = array(
    'GovDelivery' => array(
      'govdelivery_nagios_critical_threshold' => array(
        '#type'          => 'textfield',
        '#title'         => t('Critical Threshold'),
        '#default_value' => variable_get('govdelivery_nagios_critical_threshold', 5000),
        '#description'   => t('Issue a critical alert when GovDelivery has this number of messages queued. (Make this greater then the warning number)'),
      ),
      'govdelivery_nagios_warning_threshold' => array(
        '#type'          => 'textfield',
        '#title'         => t('Warning Threshold'),
        '#default_value' => variable_get('govdelivery_nagios_warning_threshold', 1000),
        '#description'   => t('Issue a warning alert when GovDelivery has this number of messages queued. (Make this less then the critical alert number)'),
      ),
    ),
  );
  return $form;
}
